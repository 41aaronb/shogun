/*!
\page developer_tutorial Libshogun and Developer Tutorial

Shogun is split up into libshogun which contains all the machine learning
algorithms, libshogunui which contains a library for the 'static interfaces',
the static interfaces python, octave, matlab, r and the modular interfaces
python_modular, octave_modular and r_modular (all found in the src/
subdirectory with corresponding name). See src/INSTALL on how to install shogun.

In case one wants to extend shogun the best way is to start using its library.
This can be easily done as a number of examples in examples/libshogun document.

The simplest libshogun based program would be

\verbinclude minimal.cpp

which could be compiled with g++ -lshogun minimal.cpp -o minimal and obviously
does nothing (apart form initializing and destroying a couple of global shogun
objects internally).

In case one wants to redirect shoguns output functions SG_DEBUG(), SG_INFO(),
SG_WARN(), SG_ERROR(), SG_PRINT() etc, one has to pass them to init_shogun() as
parameters like this

\verbatim
void print_message(FILE* target, const char* str)
{
    fprintf(target, "%s", str);
}

void print_warning(FILE* target, const char* str)
{
    fprintf(target, "%s", str);
}

void print_error(FILE* target, const char* str)
{
    fprintf(target, "%s", str);
}

init_shogun(&print_message, &print_warning,
            &print_error);
\endverbatim

To finally see some action one has to include the appropriate header files,
e.g. we create some features and a gaussian kernel

\verbinclude minimal_svm.cpp

Now you probably wonder why this example does not leak memory. First of all,
supplying pointers to arrays allocated with new[] will make shogun objects own
these objects and will make them take care of cleaning them up on object
destruction. Then, when creating shogun objects they keep a reference counter
internally. Whenever a shogun object is returned or supplied as an argument to
some function its reference counter is increased, for example in the example
above

\verbatim
CLibSVM* svm = new CLibSVM(10, kernel, labels);
\endverbatim

increases the reference count of kernel and labels. On destruction the
reference counter is decreased and the object is freed if the counter is <= 0.

It is therefore your duty to prevent objects from destruction if you keep a
handle to them globally <b>which you still intend to use later</b>. In the example
above accessing labels after the call to SG_UNREF(svm) will cause a
segmentation fault as the Label object was already destroyed in the SVM
destructor. You can do this by SG_REF(obj). To decrement the reference count of
an object, call SG_UNREF(obj) which will also automagically destroy it if the
counter is <= 0 and set obj=NULL only in this case.


Generally, all shogun C++ Objects are prefixed with C, e.g. CSVM and derived from
CSGObject. Since variables in the upper class hierarchy, need to be initialized
upon construction of the object, the constructor of base class needs to be
called in the constructor, e.g. CSVM calls CKernelMachine, CKernelMachine calls
CClassifier which finally calls CSGObject.

For example if you implement your own SVM called MySVM you would in the
constructor do

\verbatim
class MySVM : public CSVM
{
    MySVM( ) : CSVM()
    {

    }
};
\endverbatim

In case you got your object working we will happily integrate it into shogun
provided you follow a number of basic coding conventions detailed in \ref devel (see
FORMATTING for formatting instructions, MACROS on how to use and name macros,
TYPES on which types to use, FUNCTIONS on how functions should look like and
NAMING CONVENTIONS for the naming scheme. Note that in case you change the API
in a way that breaks ABI compatibility you need to increase the major number of
the libshogun soname (see \ref soname ).

*/
